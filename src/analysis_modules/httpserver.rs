use std::collections::HashMap;

use crate::lara_core::*;
use crate::ConfigField;
use core_traits::AnalysisModule;
use rand::Rng;

#[derive(Debug, Clone)]

// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData<'a> {
    logs:HashMap<String,HashMap<String,String>>,
}
pub struct HTTPServer<'a> {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData<'a>,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    lasterrorlen:usize,
    lastaccesslen:usize,
    module_name: String,
}

impl AnalysisModule for HTTPServer<'_> {
    // Use this to gather data from the host computer and store it in the current data struct,
    // This is called at the start of a tick to gather the data into CurrentData struct. If there is an error return false
    fn get_data(&mut self) -> bool {
        let errortestdata: &str ="[Wed Sep 11 13:10:31.495743 2024] [php:error] [pid 17084:tid 1904] [client ::1:53541] script 'C:/DevProjects/PersonalSite/Personal-Site/testing.php' not found or unable to stat\n[Wed Sep 11 13:17:29.031502 2024] [core:error] [pid 17084:tid 1892] (OS 5)Access is denied.  : [client ::1:53897] AH00132: file permissions deny server access: C:/DevProjects/PersonalSite/Personal-Site/tes.txt\n[Wed Sep 11 13:27:46.818722 2024] [core:error] [pid 17084:tid 1904] (OS 5)Access is denied.  : [client 192.168.0.45:50136] AH00132: file permissions deny server access: C:/DevProjects/PersonalSite/Personal-Site/tes.txt\n[Wed Sep 11 15:31:52.316572 2024] [ssl:warn] [pid 13840:tid 380] AH01909: www.example.com:443:0 server certificate does NOT include an ID which matches the server name\n[Wed Sep 11 15:31:52.342572 2024] [ssl:warn] [pid 13840:tid 380] AH01909: www.example.com:443:0 server certificate does NOT include an ID which matches the server name\n[Wed Sep 11 15:31:52.370156 2024] [mpm_winnt:notice] [pid 13840:tid 380] AH00354: Child: Starting 150 worker threads.";
        let accesstestdata: &str = "";//'::1 - - [11/Sep/2024:13:18:57 +1000] "GET /res/js/index.js HTTP/1.1" 200 1024 "http://localhost/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36 Edg/128.0.0.0"\n::1 - - [11/Sep/2024:13:18:57 +1000] "GET /res/css/styles.css?1.0.1 HTTP/1.1" 200 3852 "http://localhost/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36 Edg/128.0.0.0"\n::1 - - [11/Sep/2024:13:18:57 +1000] "GET /favicon.ico HTTP/1.1" 404 295 "http://localhost/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36 Edg/128.0.0.0"\n::1 - - [11/Sep/2024:13:19:15 +1000] "GET / HTTP/1.1" 200 495 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36 Edg/128.0.0.0"\n\n192.168.0.45 - - [11/Sep/2024:13:27:31 +1000] "GET / HTTP/1.1" 200 3967 "-" "Mozilla/5.0 (iPhone; CPU iPhone OS 18_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1 Mobile/15E148 Safari/604.1"\n192.168.0.45 - - [11/Sep/2024:13:27:31 +1000] "GET /res/js/index.js HTTP/1.1" 200 1024 "http://192.168.0.206/" "Mozilla/5.0 (iPhone; CPU iPhone OS 18_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1 Mobile/15E148 Safari/604.1"\n192.168.0.45 - - [11/Sep/2024:13:27:31 +1000] "GET /res/css/styles.css?1.0.1 HTTP/1.1" 200 3852 "http://192.168.0.206/" "Mozilla/5.0 (iPhone; CPU iPhone OS 18_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1 Mobile/15E148 Safari/604.1"\n192.168.0.45 - - [11/Sep/2024:13:27:46 +1000] "GET /tes.txt HTTP/1.1" 403 302 "-" "Mozilla/5.0 (iPhone; CPU iPhone OS 18_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1 Mobile/15E148 Safari/604.1"'
        //let errordump: &str = 
        let errordump: &str = errortestdata;
        //print!("{}",errordump);
        //let accessdump: &str = 
        let accessdump: &str = accesstestdata;
        //print!("{}",accessdump);
        let errorlines: Vec<&str> = errordump.lines().collect();
        let accesslines: Vec<&str> = accessdump.lines().collect();
        let accesslineslen: usize = accesslines.len();
        let errorlineslen: usize = errorlines.len();
        let mut elines: Vec<&str> = vec![];
        let mut alines: Vec<&str> = vec![]; 
        if accesslineslen > 0{
            let mut newalinecount:usize = accesslineslen - self.lastaccesslen;
            while newalinecount > 0{
                alines.push(accesslines[accesslineslen - newalinecount]);
                newalinecount = newalinecount - 1; 
            }
        }
        if errorlineslen > 0{
            let mut newelinecount:usize = errorlineslen - self.lasterrorlen;
            while newelinecount > 0{
                elines.push(errorlines[errorlineslen - newelinecount]);
                newelinecount = newelinecount - 1;
            }
        }
        let mut nl: &str;
        let mut i1: usize = 0;

        while i1 < elines.len(){
            nl = elines[i1];
            let nls: Vec<&str> = nl.split(&[']','[']).filter(|&r| r != "").collect();
            if nls[3].contains("php:error") || nls[3].contains("core:error"){
                let errorsplit: Vec<&str> = nl.split(nls[7]).collect();
                let nlerrormsg = errorsplit[2];
                let mut data:HashMap<String,String> = HashMap::new();
                //data.insert(nlerrormsg.to_string(),"1".to_string());
                data.insert("msg".to_string(),nlerrormsg.to_string());
                data.insert("suspicion".to_string(),"1".to_string());
                if nls[7].contains("::1"){
                    let nlip:&str = "::1";
                    self.current_data.logs.insert(nlip.to_string(),data);
                }else{
                    let ipsplit: Vec<&str> = nls[7].split(&[' ',':']).filter(|&r| r != "").collect();
                    let nlip:&str = ipsplit[1];
                    self.current_data.logs.insert(nlip.to_string(),data);
                }
            }
            i1 = i1 + 1;
        }
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<core_structs::Log> = Vec::new();

        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }
    fn build_config_fields(&self) -> Vec<crate::ConfigField> {
        let fields:Vec<ConfigField> = vec![];
        
        return fields;
    }
    fn retrieve_config_data(&mut self, data: HashMap<String,Vec<String>>) -> bool{
        for (field, vals) in data.into_iter(){
            for val in vals{
                println!("{}->{}", field, val);
            }
        }
        return true;
    }
}
// Must implement on your module, defines a default constructor. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialize an empty current data struct like this
impl Default for HTTPServer<'_> {
    fn default() -> Self {
        Self {
            lasterrorlen:0,
            lastaccesslen:0,
            module_name: String::from("HTTPServerModule"),
            current_data: CurrentData {
                logs: HashMap::new()
            },
        }
    }
}
// Must be implemented to allow copying
// basically implement this function that creates a new version of itself with every parameter identical
// impl Clone for HTTPServer<'_> {
//     fn clone(&self) -> Self {
//         Self {
//             current_data: self.current_data,
//             lasterrorlen: self.lasterrorlen.clone(),
//             lastaccesslen: self.lastaccesslen.clone(),
//             module_name: self.module_name.clone(),
//         }
//     }
// }
