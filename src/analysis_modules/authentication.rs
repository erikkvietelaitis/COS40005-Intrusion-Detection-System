use std::collections::HashMap;

use crate::lara_core::*;
use core_traits::AnalysisModule;
use crate::linux_bridge::auth;
use crate::ConfigField;
#[derive(Debug, Clone)]


struct FailedLogInIp {
    ip:String,
    num:u64
}

// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData {    
    //failed ips
    cfips: Vec<FailedLogInIp>,
    csips: Vec<FailedLogInIp>,
}
pub struct Authentication {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    //previous failed ips
    pfips: Vec<FailedLogInIp>,
    psips: Vec<FailedLogInIp>,
    lastbtmplen:usize,
    lastwtmplen:usize,
    module_name: String,
}
impl AnalysisModule for Authentication {
    // Use this to gather data from the host computer and store it in the current data strut,
    // This is called at the start of a tick to gather the data into CurrentData strut. If there is an error return false
    fn get_data(&mut self) -> bool {
        //creates a vector to place any failed login ips
        let mut fips: Vec<FailedLogInIp> = Vec::new();
        let mut sips: Vec<FailedLogInIp> = Vec::new();
        //a failedloginip object to use when placing objects into the vector 
        let mut nlflip: FailedLogInIp;
        //the actual data will be pulled by the linux bridge
        //let failtestdata: &str = "May 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.210 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.211 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)";
        //let successtestdata: &str = "May 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.210 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.211 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)";
        //seperates the file into lines
        let btmpdump: &str = &auth::btmp_dump();
        let wtmpdump: &str = &auth::wtmp_dump();
        let btmplines: Vec<&str> = btmpdump.lines().collect();
        let wtmplines: Vec<&str> = wtmpdump.lines().collect();
        let wtmplineslen: usize = wtmplines.len();
        let btmplineslen: usize = btmplines.len();
        let mut flines: Vec<&str> = vec![]; //= failtestdata.lines().collect();
        let mut slines: Vec<&str> = vec![]; //= successtestdata.lines().collect();
        if wtmplineslen > 0{
            let mut newslinecount:usize = wtmplineslen - self.lastwtmplen;
            while newslinecount > 0{
                slines.push(wtmplines[wtmplineslen - newslinecount])
            }
        }
        if btmplineslen > 0{
            let mut newflinecount:usize = btmplineslen - self.lastbtmplen;
            while newflinecount > 0{
                flines.push(btmplines[btmplineslen - newflinecount])
            }
        }
        //nl stands for new line. and will have the seperate lines placed into it for analysis
        let mut nl: &str;
        let mut i1: usize = 0;
        let mut done: bool;
        //TFC stands for Total Failure Count, it is a count of total failures to be stored and checked on the next passover to see if there are new failures to be alerted for
        //while loop that iterates through all of the lines
        while i1 < flines.len(){
            nl = flines[i1];
            //nls stands for new line split. this part of the code splits the line based on white spaces
            let nls: Vec<&str> = nl.split_whitespace().collect();
            //nlip stands for new line ip. the ip adderess should always be the 11th string in the line
            let nlip:&str =nls[1];
            //checks to see if the vector is empty
            if fips.len() != 0{
                let mut i2: usize = 0;
                //this is used to see if the ip has been handeled within the vector
                done = false;
                //this while loop checks to see if the new line ip is within the vector and if it is will increase the num by 1
                 while i2 < fips.len() {
                    if fips[i2].ip == nlip {
                        fips[i2].num = fips[i2].num + 1;
                        done = true; 
                    }
                    i2 = i2 + 1;
                }
                //if the ip is not in the vector it will be added here
                if !done{
                    //nlflip stands for new line failed login ip
                    nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                    fips.push(nlflip);
                }
            //if the vector is empty will create a new failedloginip object and place it in the vector
            }else {
                nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                fips.push(nlflip);
            }
            i1 = i1 + 1;
        }
        let mut i3: usize = 0;
        while i3 < slines.len(){
            nl = slines[i3];
            //nls stands for new line split. this part of the code splits the line based on white spaces
            let nls: Vec<&str> = nl.split_whitespace().collect();
            //nlip stands for new line ip. the ip adderess should always be the 11th string in the line
            //checks to see if the vector is empty
            if nls[1] != "system" && nls[1] != "tty2" && nls[1] != "seat0"{
                let nlip:&str =nls[2];
                if sips.len() != 0{
                    let mut i4: usize = 0;
                    //this is used to see if the ip has been handeled within the vector
                    done = false;
                    //this while loop checks to see if the new line ip is within the vector and if it is will increase the num by 1
                    while i4 < fips.len() {
                        if sips[i4].ip == nlip {
                            sips[i4].num = sips[i4].num + 1;
                            done = true; 
                        }
                        i4 = i4 + 1;
                    }
                    //if the ip is not in the vector it will be added here
                    if !done{
                        //nlflip stands for new line failed login ip
                        nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                        sips.push(nlflip);
                    }
                //if the vector is empty will create a new failedloginip object and place it in the vector
                }else {
                    nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                    sips.push(nlflip);
                }
            }
            i1 = i1 + 1;
        }
        self.lastbtmplen =  btmplineslen;
        self.lastwtmplen = wtmplineslen;
        self.current_data = CurrentData {
            cfips: fips,
            csips: sips
        };
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<core_struts::Log> = Vec::new();
        if self.current_data.cfips.len() > 0 {
            let mut i1: usize = 0;
            let mut i2: usize = 0;
            let mut inpfips: bool = false;
            while i1 < self.current_data.cfips.len() {
                inpfips = false;
                while i2 < self.pfips.len() {
                    if self.current_data.cfips[i1].ip == self.pfips[i2].ip {
                        inpfips = true;
                        self.pfips[i2].num = self.current_data.cfips[i1].num + self.pfips[i2].num;
                        
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(*&self.current_data.cfips[i1].ip.as_str());
                        msg.push_str("' has failed to log in ");
                        msg.push_str(*&self.current_data.cfips[i1].num.to_string().as_str());
                        msg.push_str("' time(s). and a total of ");
                        msg.push_str(*&self.pfips[i2].num.to_string().as_str());
                        msg.push_str("' times in the past (undecided amount of time)");
                        if self.pfips[i2].num < 3 as u64{
                            results.push(core_struts::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 10 as u64 {
                            results.push(core_struts::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 1000 as u64{
                            results.push(core_struts::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                        } else{
                            results.push(core_struts::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                        }
                    }
                    i2 = i2 + 1;    
                }
                if !inpfips{
                    let mut msg: String = String::from("ip address '");
                    msg.push_str(&self.current_data.cfips[i1].ip.as_str());
                    msg.push_str("' has failed to log in ");
                    msg.push_str(&self.current_data.cfips[i1].num.to_string().as_str());
                    msg.push_str("' time(s)");
                    if self.current_data.cfips[i1].num < 3{
                        results.push(core_struts::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    } else if self.current_data.cfips[i1].num < 10{
                        results.push(core_struts::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                    } else if self.current_data.cfips[i1].num < 1000{
                        results.push(core_struts::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                    } else {
                        results.push(core_struts::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                    }
                    let t = &self.current_data.cfips[i1];
                    self.pfips.push(t.clone());
                }
                i1 = i1 + 1;
            }
        }
        if self.current_data.csips.len() > 0 {
            let mut i1: usize = 0;
            let mut i2: usize = 0;
            let mut i3: usize = 0;
            let mut inpsips: bool = false;
            while i1 < self.current_data.csips.len() {
                while i2 < self.current_data.cfips.len(){
                    if self.current_data.csips[i1].ip == self.pfips[i2].ip {
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(&self.current_data.csips[i1].ip.as_str());
                        msg.push_str("' has successfully logged in after");
                        msg.push_str(&self.pfips[i2].num.to_string().as_str());
                        msg.push_str("' failed attempts");
                        if self.pfips[i2].num < 3{
                            results.push(core_struts::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 10{
                            results.push(core_struts::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 1000{
                            results.push(core_struts::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                        } else{
                            results.push(core_struts::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                        }
                    }
                    i2 = i2 + 1;
                }
                inpsips = false;
                while i3 < self.psips.len() {
                    if self.current_data.csips[i1].ip == self.psips[i3].ip {
                        inpsips = true;
                        self.psips[i3].num = self.current_data.csips[i1].num + self.psips[i3].num;
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(&self.current_data.csips[i1].ip.as_str());
                        msg.push_str("' has succefully logged in ");
                        msg.push_str(&self.current_data.csips[i1].num.to_string().as_str());
                        msg.push_str("' time(s). and a total of ");
                        msg.push_str(&self.psips[i2].num.to_string().as_str());
                        msg.push_str("' times in the past (undecided amount of time)");
                        results.push(core_struts::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    }
                    i3 = i3 + 1;    
                }
                if !inpsips{
                    let mut msg: String = String::from("ip address '");
                    msg.push_str(&self.current_data.csips[i1].ip.as_str());
                    msg.push_str("' has logged in seccesfully ");
                    msg.push_str(&self.current_data.csips[i1].num.to_string().as_str());
                    msg.push_str("' time(s)");
                    results.push(core_struts::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    let t = &self.current_data.csips[i1];
                    self.psips.push(t.clone());
                }
                i1 = i1 + 1;
            }
        }
        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }

    fn build_config_fields(&self) -> Vec<crate::ConfigField> {
        let fields:Vec<ConfigField> = vec![];
        return fields;
    }
    fn retrieve_config_data(&mut self, data: HashMap<String,Vec<String>>) -> bool{
        return true;
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for Authentication {
    fn default() -> Self {
        Self {
            module_name: String::from("Authentication"),
            pfips: vec![],
            psips: vec![],
            lastbtmplen:0,
            lastwtmplen:0,
            current_data: CurrentData {
                cfips: vec![],
                csips: vec![],
            },
        }
    }
}