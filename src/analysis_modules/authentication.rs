use std::collections::HashMap;

use crate::lara_core::*;
use core_traits::AnalysisModule;
use crate::linux_bridge::auth;
use crate::ConfigField;
#[derive(Debug, Clone)]


struct FailedLogInIp {
    ip:String,
    num:u64
}

// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData {    
    //failed ips
    cfips: Vec<FailedLogInIp>,
    csips: Vec<FailedLogInIp>,
}
pub struct Authentication {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    //previous failed ips
    pfips: Vec<FailedLogInIp>,
    psips: Vec<FailedLogInIp>,
    lastbtmplen:usize,
    lastwtmplen:usize,
    initialbtmp:bool,
    initialwtmp:bool,
    module_name: String,
}
impl AnalysisModule for Authentication {
    // Use this to gather data from the host computer and store it in the current data strut,
    // This is called at the start of a tick to gather the data into CurrentData strut. If there is an error return false
    fn get_data(&mut self) -> bool {
        //creates a vector to place any failed login ips
        let mut fips: Vec<FailedLogInIp> = Vec::new();
        let mut sips: Vec<FailedLogInIp> = Vec::new();
        //a failedloginip object to use when placing objects into the vector 
        let mut nlflip: FailedLogInIp;
        //the actual data will be pulled by the linux bridge
        let failtestdata: &str = "root     ssh:notty    218.92.0.158     Wed Mar 13 14:34 - 14:34  (00:00)\nsindesi  ssh:notty    59.164.69.10     Wed Mar 13 14:34 - 14:34  (00:00)/nroot     ssh:notty    218.92.0.158     Wed Mar 13 14:34 - 14:34  (00:00)\nsindesi  ssh:notty    59.164.69.10     Wed Mar 13 14:34 - 14:34  (00:00)\nroot     ssh:notty    218.92.0.158     Wed Mar 13 14:34 - 14:34  (00:00)";
        //let successtestdata: &str = "ids      tty2         tty2             Sun Sep  8 09:28   still logged in\nids      seat0        login screen     Sun Sep  8 09:28   still logged in\nreboot   system boot  6.8.0-41-generic Sun Sep  8 09:27   still running\nids      tty2         tty2             Sun Sep  8 08:24 - crash  (01:03)\nids      seat0        login screen     Sun Sep  8 08:24 - crash  (01:03)\nreboot   system boot  6.8.0-41-generic Sun Sep  8 08:23   still running\nreboot   system boot  6.8.0-41-generic Fri Sep  6 14:24   still running\nids      tty2         tty2             Tue Sep  3 11:13 - crash (3+03:10)\nids      seat0        login screen     Tue Sep  3 11:13 - crash (3+03:10)\nreboot   system boot  6.8.0-41-generic Tue Sep  3 11:13   still running\nids      tty2         tty2             Mon Sep  2 12:16 - crash  (22:57)\nids      seat0        login screen     Mon Sep  2 12:16 - crash  (22:57)\nreboot   system boot  6.8.0-41-generic Mon Sep  2 12:15   still running\nreboot   system boot  6.8.0-41-generic Mon Sep  2 12:11   still running\nids      tty2         tty2             Tue Aug 27 17:59 - crash (5+18:12)\nids      seat0        login screen     Tue Aug 27 17:59 - crash (5+18:12)\nreboot   system boot  6.8.0-40-generic Tue Aug 27 17:58   still running\nids      tty2         tty2             Mon Aug 26 23:02 - crash  (18:55)\nids      seat0        login screen     Mon Aug 26 23:02 - crash  (18:55)\nreboot   system boot  6.8.0-40-generic Mon Aug 26 23:02   still running\nids      tty2         tty2             Mon Aug 26 22:54 - crash  (00:08)\nids      seat0        login screen     Mon Aug 26 22:54 - crash  (00:08)\nreboot   system boot  6.8.0-40-generic Mon Aug 26 22:53   still running\nreboot   system boot  6.8.0-40-generic Mon Aug 26 22:51   still running\nreboot   system boot  6.8.0-40-generic Mon Aug 26 22:45   still running\nreboot   system boot  6.8.0-40-generic Thu Aug 22 14:01   still running\nids      tty2         tty2             Wed Aug 21 16:13 - down   (00:29)\nids      seat0        login screen     Wed Aug 21 16:13 - down   (00:29)\nreboot   system boot  6.8.0-40-generic Wed Aug 21 16:11 - 16:43  (00:31)\nids      tty2         tty2             Tue Aug 20 20:29 - down   (19:42)\nids      seat0        login screen     Tue Aug 20 20:29 - down   (19:42)\nreboot   system boot  6.8.0-31-generic Tue Aug 20 20:28 - 16:11  (19:43)\nids      tty2         tty2             Tue Aug 20 20:27 - down   (00:00)\nids      seat0        login screen     Tue Aug 20 20:27 - down   (00:00)\nreboot   system boot  6.8.0-31-generic Tue Aug 20 20:24 - 20:27  (00:03)";
        //seperates the file into lines
        let btmpdump: &str = &auth::btmp_dump();
        //let btmpdump: &str = failtestdata;
        //print!("{}",btmpdump);
        let wtmpdump: &str = &auth::wtmp_dump();
        //let wtmpdump: &str = successtestdata;
        //print!("{}",wtmpdump);
        let btmplines: Vec<&str> = btmpdump.lines().collect();
        let wtmplines: Vec<&str> = wtmpdump.lines().collect();
        let wtmplineslen: usize = wtmplines.len();
        let btmplineslen: usize = btmplines.len();
        let mut flines: Vec<&str> = vec![]; //= failtestdata.lines().collect();
        let mut slines: Vec<&str> = vec![]; //= successtestdata.lines().collect();
        if self.initialbtmp && btmplineslen>0{
            self.lastbtmplen = btmplineslen;
            self.initialbtmp = true;
        }
        if self.initialwtmp && wtmplineslen>0{
            self.lastwtmplen = wtmplineslen;
            self.initialwtmp = true;
        }
        if wtmplineslen > 0{
            let mut newslinecount:usize = wtmplineslen - self.lastwtmplen;
            while newslinecount > 0{
                slines.push(wtmplines[wtmplineslen - newslinecount]);
                newslinecount = newslinecount - 1; 
            }
        }
        if btmplineslen > 0{
            let mut newflinecount:usize = btmplineslen - self.lastbtmplen;
            while newflinecount > 0{
                flines.push(btmplines[btmplineslen - newflinecount]);
                newflinecount = newflinecount - 1;
            }
        }
        //nl stands for new line. and will have the seperate lines placed into it for analysis
        let mut nl: &str;
        let mut i1: usize = 0;
        let mut done: bool;
        //TFC stands for Total Failure Count, it is a count of total failures to be stored and checked on the next passover to see if there are new failures to be alerted for
        //while loop that iterates through all of the lines
        while i1 < flines.len(){
            nl = flines[i1];
            //nls stands for new line split. this part of the code splits the line based on white spaces
            let nls: Vec<&str> = nl.split("[").collect();
            //nlip stands for new line ip. the ip adderess should always be the 11th string in the line
            let nlipsplit: Vec<&str> =nls[7].split_whitespace().collect();
            let nlip:&str = nlipsplit[0];
            //checks to see if the vector is empty
            if fips.len() != 0{
                let mut i2: usize = 0;
                //this is used to see if the ip has been handeled within the vector
                done = false;
                //this while loop checks to see if the new line ip is within the vector and if it is will increase the num by 1
                 while i2 < fips.len() {
                    if fips[i2].ip == nlip {
                        fips[i2].num = fips[i2].num + 1;
                        done = true; 
                    }
                    i2 = i2 + 1;
                }
                //if the ip is not in the vector it will be added here
                if !done{
                    //nlflip stands for new line failed login ip
                    nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                    fips.push(nlflip);
                }
            //if the vector is empty will create a new failedloginip object and place it in the vector
            }else {
                nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                fips.push(nlflip);
            }
            i1 = i1 + 1;
        }
        let mut i3: usize = 0;
        while i3 < slines.len(){
            nl = slines[i3];
            //nls stands for new line split. this part of the code splits the line based on white spaces
            let nls: Vec<&str> = nl.split("[").collect();
            //nlip stands for new line ip. the ip adderess should always be the 11th string in the line
            //checks to see if the vector is empty
            //print!("{}",nls[3]);
            if !nls[4].contains("reboot") && !nls[4].contains("runlevel") && !nls[4].contains("shutdown") && !nls[5].contains("tty2"){
                //print!("{}",nls[3]);
                //print!("{}",nls[4]);
                let nlipsplit: Vec<&str> =nls[7].split_whitespace().collect();
                let nlip:&str = nlipsplit[0];
                if sips.len() != 0{
                    let mut i4: usize = 0;
                    //this is used to see if the ip has been handeled within the vector
                    done = false;
                    //this while loop checks to see if the new line ip is within the vector and if it is will increase the num by 1
                    while i4 < sips.len() {
                        if sips[i4].ip == nlip {
                            sips[i4].num = sips[i4].num + 1;
                            done = true; 
                        }
                        i4 = i4 + 1;
                        //print!("{}",i4);
                        //print!("{}\n",nl);
                    }
                    //if the ip is not in the vector it will be added here
                    if !done{
                        //nlflip stands for new line failed login ip
                        nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                        sips.push(nlflip);
                    }
                //if the vector is empty will create a new failedloginip object and place it in the vector
                }else {
                    nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                    sips.push(nlflip);
                }
            }
            i3 = i3 + 1;
        }
        self.lastbtmplen =  btmplineslen;
        self.lastwtmplen = wtmplineslen;
        self.current_data = CurrentData {
            cfips: fips,
            csips: sips
        };
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<core_structs::Log> = Vec::new();
        if self.current_data.cfips.len() > 0 {
            let mut i1: usize = 0;
            let mut i2: usize = 0;
            let mut inpfips: bool = false;
            while i1 < self.current_data.cfips.len() {
                inpfips = false;
                while i2 < self.pfips.len() {
                    if self.current_data.cfips[i1].ip == self.pfips[i2].ip {
                        inpfips = true;
                        self.pfips[i2].num = self.current_data.cfips[i1].num + self.pfips[i2].num;
                        
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(*&self.current_data.cfips[i1].ip.as_str());
                        msg.push_str("' has failed to log in ");
                        msg.push_str(*&self.current_data.cfips[i1].num.to_string().as_str());
                        msg.push_str("' time(s). and a total of ");
                        msg.push_str(*&self.pfips[i2].num.to_string().as_str());
                        msg.push_str("' times in the past (undecided amount of time)");
                        if self.pfips[i2].num < 3 as u64{
                            results.push(core_structs::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 10 as u64 {
                            results.push(core_structs::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 1000 as u64{
                            results.push(core_structs::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                        } else{
                            results.push(core_structs::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                        }
                    }
                    i2 = i2 + 1;    
                }
                if !inpfips{
                    let mut msg: String = String::from("ip address '");
                    msg.push_str(&self.current_data.cfips[i1].ip.as_str());
                    msg.push_str("' has failed to log in ");
                    msg.push_str(&self.current_data.cfips[i1].num.to_string().as_str());
                    msg.push_str("' time(s)");
                    if self.current_data.cfips[i1].num < 3{
                        results.push(core_structs::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    } else if self.current_data.cfips[i1].num < 10{
                        results.push(core_structs::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                    } else if self.current_data.cfips[i1].num < 1000{
                        results.push(core_structs::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                    } else {
                        results.push(core_structs::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                    }
                    let t = &self.current_data.cfips[i1];
                    self.pfips.push(t.clone());
                }
                i1 = i1 + 1;
            }
        }
        if self.current_data.csips.len() > 0 {
            let mut i1: usize = 0;
            let mut i2: usize = 0;
            let mut i3: usize = 0;
            let mut inpsips: bool = false;
            while i1 < self.current_data.csips.len() {
                while i2 < self.current_data.cfips.len(){
                    if self.current_data.csips[i1].ip == self.pfips[i2].ip {
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(&self.current_data.csips[i1].ip.as_str());
                        msg.push_str("' has successfully logged in after ");
                        msg.push_str(&self.pfips[i2].num.to_string().as_str());
                        msg.push_str("' failed attempts");
                        if self.pfips[i2].num < 3{
                            results.push(core_structs::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 10{
                            results.push(core_structs::Log::new(core_enums::LogType::Warning,self.module_name.clone(),msg,));
                        } else if self.pfips[i2].num < 1000{
                            results.push(core_structs::Log::new(core_enums::LogType::Serious,self.module_name.clone(),msg,));
                        } else{
                            results.push(core_structs::Log::new(core_enums::LogType::Critical,self.module_name.clone(),msg,));
                        }
                    }
                    i2 = i2 + 1;
                }
                inpsips = false;
                while i3 < self.psips.len() {
                    if self.current_data.csips[i1].ip == self.psips[i3].ip {
                        inpsips = true;
                        self.psips[i3].num = self.current_data.csips[i1].num + self.psips[i3].num;
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(&self.current_data.csips[i1].ip.as_str());
                        msg.push_str("' has succefully logged in ");
                        msg.push_str(&self.current_data.csips[i1].num.to_string().as_str());
                        msg.push_str("' time(s). and a total of ");
                        msg.push_str(&self.psips[i2].num.to_string().as_str());
                        msg.push_str("' times in the past (undecided amount of time)");
                        results.push(core_structs::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    }
                    i3 = i3 + 1;    
                }
                if !inpsips{
                    let mut msg: String = String::from("ip address '");
                    msg.push_str(&self.current_data.csips[i1].ip.as_str());
                    msg.push_str("' has logged in seccesfully ");
                    msg.push_str(&self.current_data.csips[i1].num.to_string().as_str());
                    msg.push_str("' time(s)");
                    results.push(core_structs::Log::new(core_enums::LogType::Info,self.module_name.clone(),msg,));
                    let t = &self.current_data.csips[i1];
                    self.psips.push(t.clone());
                }
                i1 = i1 + 1;
            }
        }
        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }

    fn build_config_fields(&self) -> Vec<crate::ConfigField> {
        let fields:Vec<ConfigField> = vec![];
        return fields;
    }
    fn retrieve_config_data(&mut self, data: HashMap<String,Vec<String>>) -> bool{
        return true;
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for Authentication {
    fn default() -> Self {
        Self {
            module_name: String::from("Authentication"),
            pfips: vec![],
            psips: vec![],
            lastbtmplen:0,
            lastwtmplen:0,
            initialbtmp:false,
            initialwtmp:false,
            current_data: CurrentData {
                cfips: vec![],
                csips: vec![],
            },
        }
    }
}