use crate::LaraCore::*;
use rand::{seq::SliceRandom, Rng};
use CoreTraits::AnalysisModule;
#[derive(Debug, Copy, Clone)]


struct FailedLogInIp {
    ip:String,
    num:u64
}
// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData<'a> {
    //failed ips
    fips: Vec<FailedLogInIp>,
}
pub struct Authentication<'a> {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData<'a>,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    //previous failed ips
    pfips: Vec<FailedLogInIp>,
    module_name: String,
}
impl AnalysisModule for Authentication<'_> {
    // Use this to gather data from the host computer and store it in the current data strut,
    // This is called at the start of a tick to gather the data into CurrentData strut. If there is an error return false
    fn get_data(&mut self) -> bool {
        //creates a vector to place any failed login ips
        let mut ips: Vec<FailedLogInIp> = Vec::new();
        //a failedloginip object to use when placing objects into the vector 
        let mut nlflip: FailedLogInIp;
        //the actual data will be pulled by the linux bridge
        let testdata: &str = "May 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.210 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: Failed password for root from 202.91.66.210 port 51566 ssh2\nMay 21 04:40:25 centos.2daygeek.com sshd[1282]: pam_unix(sshd:session): session not opened for user root by (uid=0)\nMay 21 07:05:31 centos.2daygeek.com sshd[19383]: pam_unix(sshd:session): session closed for user nagios\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: Accepted password for root from 202.91.66.210 port 34457 ssh2\nMay 21 07:09:14 centos.2daygeek.com sshd[4632]: pam_unix(sshd:session): session opened for user root by (uid=0)\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: Failed password for nagios from 202.91.66.211 port 58244 ssh2\nMay 21 11:21:03 centos.2daygeek.com sshd[11179]: pam_unix(sshd:session): session not opened for user nagios by (uid=0)";
        //seperates the file into lines
        let lines: Vec<&str> = testdata.lines().collect();
        //nl stands for new line. and will have the seperate lines placed into it for analysis
        let mut nl: &str;
        let mut i1: usize = 0;
        let mut done: bool;
        //TFC stands for Total Failure Count, it is a count of total failures to be stored and checked on the next passover to see if there are new failures to be alerted for
        let mut TFC : i32 = 0;
        //while loop that iterates through all of the lines
        while i1 < lines.len(){
            nl = lines[i1];
            //checks if the current line is a login fail
            if nl.contains("Failed") {
                //increases total failure count
                TFC = TFC + 1;

                //nls stands for new line split. this part of the code splits the line based on white spaces
                let nls: Vec<&str> = nl.split_whitespace().collect();
                //nlip stands for new line ip. the ip adderess should always be the 11th string in the line
                let nlip:&str =nls[10];
                //checks to see if the vector is empty
                if ips.len() != 0{
                    let mut i2: usize = 0;
                    //this is used to see if the ip has been handeled within the vector
                    done = false;
                    //this while loop checks to see if the new line ip is within the vector and if it is will increase the num by 1
                    while i2 < ips.len() {
                        if ips[i2].ip == nlip {
                            ips[i2].num = ips[i2].num + 1;
                            done = true; 
                        }
                        i2 = i2 + 1;
                    }
                    //if the ip is not in the vector it will be added here
                    if !done{
                        //nlflip stands for new line failed login ip
                        nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                        ips.push(nlflip);
                    }
                //if the vector is empty will create a new failedloginip object and place it in the vector
                }else {
                    nlflip = FailedLogInIp{ip:nlip.to_string(),num:1};
                    ips.push(nlflip);
                }
            }
            i1 = i1 + 1;
        }
    

        self.current_data = CurrentData {
            fips: ips,
        };
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<CoreStruts::Log> = Vec::new();
        let mut i1: usize = 0;
        let mut i2: usize = 0;
        let mut inpfips: bool = false;
        while i1 < self.current_data.fips.len() {
            while i2 < self.pfips.len() {
                if self.current_data.fips[i1].ip == self.pfips[i2].ip {
                    if self.current_data.fips[i1].num > self.pfips[i2].num {
                        let mut msg: String = String::from("ip address '");
                        msg.push_str(&self.current_data.fips[i1].ip);
                        msg.push_str("' has failed to log in ");
                        msg.push_str(&self.current_data.fips[i1].num.to_string());
                        msg.push_str("' time(s)");
                        results.push(CoreStruts::Log::new(CoreEnums::LogType::Serious,self.module_name.clone(),msg,));
                    }
                    inpfips=true;
                }
                i2 = i2 + 1;    
            }
            if !inpfips{
                let mut msg: String = String::from("ip address '");
                msg.push_str(&self.current_data.fips[i1].ip);
                msg.push_str("' has failed to log in ");
                msg.push_str(&self.current_data.fips[i1].num.to_string());
                msg.push_str("' time(s)");
                results.push(CoreStruts::Log::new(CoreEnums::LogType::Serious,self.module_name.clone(),msg,));
            }
            i1 = i1 + 1;
        }
        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for Authentication<'_> {
    fn default() -> Self {
        Self {
            module_name: String::from("Authentication"),
            pfips: vec![],
            current_data: CurrentData {
                fips: vec![],
            },
        }
    }
}
// Must be implemented to allow copying
// basically implement this function that creates a new version of itself with every parameter identical
impl Clone for Authentication<'_> {
    fn clone(&self) -> Self {
        Self {
            current_data: self.current_data,
            pfips: self.pfips.clone(),
            module_name: self.module_name.clone(),
        }
    }
}
