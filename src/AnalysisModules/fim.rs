use crate::LaraCore::*;
use CoreTraits::AnalysisModule;
use std::collections::HashMap;
use std::process::Command;

#[derive(Debug, Clone)]
// Define the set of data that will be captured each tick
struct CurrentData {
    new_hashes: HashMap<String, String>,
    // You can uncomment and use these fields if needed
    // some_count_of_something: u8,
    // something_else: f32,
}

pub struct FIM {
    // This is the data generated by gatherData in the current tick, it will be erased by the next tick
    current_data: CurrentData,
    // Everything else is persistent memory. The data you set in these will be remembered between ticks
    pub previous_hashes: HashMap<String, String>,
    module_name: String,
}

// Function to generate hash using the key
fn genhash(key: &str) -> (bool, String) {
    let output = match Command::new("b3sum")
        .arg(key)
        .output() {
        Ok(output) => output,
        Err(err) => {
            eprintln!("Failed to execute command for key '{}': {}", key, err);
            return (false, String::new());
        }
    };
    // Convert output to string
    let stdout_str = String::from_utf8_lossy(&output.stdout).into_owned();
    let stderr_str = String::from_utf8_lossy(&output.stderr).into_owned();

    if !stderr_str.is_empty() {
        eprintln!("stderr for key '{}': {}", key, stderr_str);
    }

    (true, stdout_str)
}

// Update section function
fn update_section(section: &mut HashMap<String, String>) -> bool {
    let mut updated_section = HashMap::new();
    let mut success = true;

    for key in section.keys().cloned() {
        // Generate hash using the key
        let (hash_success, hash) = genhash(&key);

        if hash_success {
            // Insert the key and hash into the updated HashMap
            updated_section.insert(key, hash);
        } else {
            eprintln!("Failed to generate hash for key '{}'", key);
            success = false;
        }
    }

    *section = updated_section;
    success
}

impl AnalysisModule for FIM {
    // Gather data from the host computer and store it in the current_data struct
    fn get_data(&mut self) -> bool {
        // Retrieve file paths from config (assuming config is correctly defined)
        let mut section = HashMap::new();
        section.insert("/etc/passwd".to_string(), "value1".to_string());
        section.insert("/etc/shadow".to_string(), "value1".to_string());
        section.insert("/home/ids/Documents/GitHub/COS40005-Intrusion-Detection-System/test".to_string(), "value1".to_string());

        // Update the section and handle the result
        if !update_section(&mut self.previous_hashes) {
            return false; // Return false if update_section fails
        }

        // Initialize new_hashes with the updated hashes
        let new_hashes = self.previous_hashes.clone();

        

        self.current_data = CurrentData {
            new_hashes,
            // Uncomment and initialize if needed
            // some_count_of_something: rand::thread_rng().gen_range(0..100),
            // something_else: rand::thread_rng().gen_range(0.0..1000.0),
        };

        true
    }

    // Return a consistent predictable dataset for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }

    // Perform analysis based on current data and persistent data
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<crate::Log> = Vec::new();
    
        // Iterate over each filepath and hash in the new_hashes
        for (filepath, new_hash) in &self.current_data.new_hashes {
            match self.previous_hashes.get(filepath) {
                // If filepath exists in previous_hashes, compare hashes
                Some(previous_hash) => {
                    if new_hash != previous_hash {
                        // If hashes differ, create a log entry
                        let msg = format!(
                            "File '{}' was modified. Previous hash: '{}', New hash: '{}'",
                            filepath, previous_hash, new_hash
                        );
                        results.push(crate::Log::new(
                            CoreEnums::LogType::Serious,
                            self.module_name.clone(),
                            msg,
                        ));
                    }
                }
                // If filepath does not exist in previous_hashes, ignore it
                None => {
                    continue;
                }
            }
        }
    
        // Update previous_hashes to be the same as new_hashes
        self.previous_hashes = self.current_data.new_hashes.clone();
    
        // Optionally, update history_of_filenames or other fields if needed
        // For example, you might want to update `history_of_filenames` as follows:
    
        results
    }
    

    // Get the name of the module
    fn get_name(&self) -> String {
        self.module_name.clone()
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for FIM {
    fn default() -> Self {
        Self {
            previous_hashes: HashMap::new(),
            module_name: String::from("FIM"),
            current_data: CurrentData {
                new_hashes: HashMap::new(),
            },
        }
    }
}
// Must be implemented to allow copying
// basically implement this function that creates a new version of itself with every parameter identical
impl Clone for FIM {
    fn clone(&self) -> Self {
        Self {
            current_data: self.current_data.clone(),
            previous_hashes: self.previous_hashes.clone(),
            module_name: self.module_name.clone(),
        }
    }
}
