use crate::LaraCore::*;
use rand::{seq::SliceRandom, Rng};
use CoreTraits::AnalysisModule;
use std::collections::HashMap;
use std::process::Command;

#[derive(Debug, Copy, Clone)]
// Define the set of data that will be captured each tick
struct CurrentData<'a> {
    new_hashes: HashMap<String, String>,
    // You can uncomment and use these fields if needed
    // some_count_of_something: u8,
    // something_else: f32,
}

pub struct FIM<'a> {
    // This is the data generated by gatherData in the current tick, it will be erased by the next tick
    current_data: CurrentData<'a>,
    // Everything else is persistent memory. The data you set in these will be remembered between ticks
    pub previous_hashes: HashMap<String, String>,
    pub history_of_filenames: Vec<&'a str>,
    blacklisted_filenames: Vec<String>,
    module_name: String,
    last_string: &'a str,
}

// Function to generate hash using the key
fn genhash(key: &str) -> (bool, String) {
    let output = match Command::new("b3sum")
        .arg(key)
        .output() {
        Ok(output) => output,
        Err(err) => {
            eprintln!("Failed to execute command for key '{}': {}", key, err);
            return (false, String::new());
        }
    };
    // Convert output to string
    let stdout_str = String::from_utf8_lossy(&output.stdout).into_owned();
    let stderr_str = String::from_utf8_lossy(&output.stderr).into_owned();

    if !stderr_str.is_empty() {
        eprintln!("stderr for key '{}': {}", key, stderr_str);
    }

    (true, stdout_str)
}

// Update section function
fn update_section(section: &mut HashMap<String, String>) -> bool {
    let mut updated_section = HashMap::new();
    let mut success = true;

    for key in section.keys().cloned() {
        // Generate hash using the key
        let (hash_success, hash) = genhash(&key);

        if hash_success {
            // Insert the key and hash into the updated HashMap
            updated_section.insert(key, hash);
        } else {
            eprintln!("Failed to generate hash for key '{}'", key);
            success = false;
        }
    }

    *section = updated_section;
    success
}

impl AnalysisModule for FIM<'_> {
    // Gather data from the host computer and store it in the current_data struct
    fn get_data(&mut self) -> bool {
        // Retrieve file paths from config (assuming config is correctly defined)
        let section = match config.section("FIM_FILEPATHS") {
            Ok(section) => section,
            Err(_) => {
                eprintln!("Section 'FIM_FILEPATHS' not found");
                return false;
            }
        };

        // Update the section and handle the result
        if !update_section(&mut self.previous_hashes) {
            return false; // Return false if update_section fails
        }

        // Initialize new_hashes with the updated hashes
        let new_hashes = self.previous_hashes.clone();

        // Example data generation
        let stringiest: Vec<&str> = vec![
            "randomName.txt",
            "Invoice.pdf.scr",
            "test.xml",
            "passwords.docs",
            "testing.png",
        ];

        self.current_data = CurrentData {
            new_hashes,
            // Uncomment and initialize if needed
            // some_count_of_something: rand::thread_rng().gen_range(0..100),
            // something_else: rand::thread_rng().gen_range(0.0..1000.0),
        };

        true
    }

    // Return a consistent predictable dataset for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }

    // Perform analysis based on current data and persistent data
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<crate::Log> = Vec::new();
    
        // Iterate over each filepath and hash in the new_hashes
        for (filepath, new_hash) in &self.current_data.new_hashes {
            match self.previous_hashes.get(filepath) {
                // If filepath exists in previous_hashes, compare hashes
                Some(previous_hash) => {
                    if new_hash != previous_hash {
                        // If hashes differ, create a log entry
                        let msg = format!(
                            "File '{}' was modified. Previous hash: '{}', New hash: '{}'",
                            filepath, previous_hash, new_hash
                        );
                        results.push(crate::Log::new(
                            CoreEnums::LogType::Serious,
                            self.module_name.clone(),
                            msg,
                        ));
                    }
                }
                // If filepath does not exist in previous_hashes, ignore it
                None => {
                    continue;
                }
            }
        }
    
        // Update previous_hashes to be the same as new_hashes
        self.previous_hashes = self.current_data.new_hashes.clone();
    
        // Optionally, update history_of_filenames or other fields if needed
        // For example, you might want to update `history_of_filenames` as follows:
        self.history_of_filenames = self.current_data.new_hashes.keys().cloned().collect();
    
        self.last_string = self.current_data.new_hashes.keys().next().unwrap_or(&"".to_string());
    
        results
    }
    

    // Get the name of the module
    fn get_name(&self) -> String {
        self.module_name.clone()
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for FIM<'_> {
    fn default() -> Self {
        Self {
            history_of_filenames: vec![],
            blacklisted_filenames: vec![],
            module_name: String::from("FIM"),
            current_data: CurrentData {
                some_file_name: "",
                some_count_of_something: 0,
                something_else: 0.0,
            },
        }
    }
}
// Must be implemented to allow copying
// basically implement this function that creates a new version of itself with every parameter identical
impl Clone for FIM<'_> {
    fn clone(&self) -> Self {
        Self {
            current_data: self.current_data,
            last_string: self.last_string,
            history_of_filenames: self.history_of_filenames.clone(),
            blacklisted_filenames: self.blacklisted_filenames.clone(),
            module_name: self.module_name.clone(),
        }
    }
}
