use std::collections::HashMap;

use crate::{ConfigField, LaraCore::*};
use rand::{Rng};

use CoreTraits::AnalysisModule;
#[derive(Debug, Copy, Clone)]

// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData<'a> {
    some_file_name: &'a str,
    some_count_of_something: u8,
    something_else: f32,
}
pub struct Example<'a> {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData<'a>,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    last_string: &'a str,
    pub history_of_filenames: Vec<&'a str>,

    blacklisted_filenames: Vec<String>,
    module_name: String,
}

impl AnalysisModule for Example<'_> {
    // Use this to gather data from the host computer and store it in the current data strut,
    // This is called at the start of a tick to gather the data into CurrentData strut. If there is an error return false
    fn get_data(&mut self) -> bool {
        let stringiest: Vec<&str> = vec![
            "randomName.txt",
            "Invoice.pdf.scr",
            "test.xml",
            "passwords.docs",
            "testing.png",
        ];

        self.current_data = CurrentData {
            some_file_name: stringiest[rand::thread_rng().gen_range(0, 4)],
            some_count_of_something: rand::thread_rng().gen_range(0, 100),
            something_else: rand::thread_rng().gen_range(0.0, 1000.0),
        };
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<CoreStruts::Log> = Vec::new();
        if self.history_of_filenames.contains(&self.current_data.some_file_name)
        {
            let mut msg: String = String::from("File '");
            msg.push_str(&self.current_data.some_file_name);
            msg.push_str("' was opened twice recently");
            results.push(CoreStruts::Log::new(CoreEnums::LogType::Serious,self.module_name.clone(),msg,));
            self.history_of_filenames = Vec::new();
        } else {
            self.history_of_filenames
                .push(self.current_data.some_file_name);
        }
        self.last_string = self.current_data.some_file_name;
        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }
    fn build_config_fields(&self) -> Vec<crate::ConfigField> {
        let fields:Vec<ConfigField> = vec![
            ConfigField::new("fileName".to_owned(),"The name of your favorite file, must be single string".to_owned(),CoreEnums::ConfigFieldType::String,vec!["config.ini".to_owned()], false),
            ConfigField::new("CoolestFileTypes".to_owned(),"The coolest file types".to_owned(),CoreEnums::ConfigFieldType::String,vec![".ini".to_owned(),".csv".to_owned(),".webp".to_owned(),".rs".to_owned()], true),
            ConfigField::new("Cool Number".to_owned(),"The coolest number".to_owned(),CoreEnums::ConfigFieldType::Integer,vec!["1".to_owned(),"299792458".to_owned(),"69".to_owned(),"329".to_owned()], true)
        ];
        
        return fields;
    }
    fn insert_config_data(&self, data: HashMap<String,Vec<String>>) -> bool{
        for (field, vals) in data.into_iter(){
            
            for val in vals{
                println!("{}->{}", field, val);
            }
        }
        return true;
    }
}
// Must implement on your module, defines a default constructor. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialize an empty current data strut like this
impl Default for Example<'_> {
    fn default() -> Self {
        Self {
            last_string: "",
            history_of_filenames: vec![],
            blacklisted_filenames: vec![],
            module_name: String::from("ExampleModule"),
            current_data: CurrentData {
                some_file_name: "",
                some_count_of_something: 0,
                something_else: 0.0,
            },
        }
    }
}
// Must be implemented to allow copying
// basically implement this function that creates a new version of itself with every parameter identical
impl Clone for Example<'_> {
    fn clone(&self) -> Self {
        Self {
            current_data: self.current_data,
            last_string: self.last_string,
            history_of_filenames: self.history_of_filenames.clone(),
            blacklisted_filenames: self.blacklisted_filenames.clone(),
            module_name: self.module_name.clone(),
        }
    }
}
