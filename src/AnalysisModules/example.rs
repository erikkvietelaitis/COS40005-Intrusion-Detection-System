use crate::LaraCore::*;
use rand::{seq::SliceRandom, Rng};
use CoreTraits::AnalysisModule;

// define the set of data that will be captured each tick, You can structure this however you like to fit your needs, Just call it this name
struct CurrentData<'a> {
    some_file_name: &'a str,
    some_count_of_something: u8,
    something_else: f32,
}
pub struct Example<'a> {
    // This is the data generated by gatherData in current tick, it will be erased by the next tick
    current_data: CurrentData<'a>,
    //Everything else is persistent memory. The data you set in these will be remembered between ticks
    last_string: &'a str,
    pub history_of_filenames: Vec<&'a str>,

    blacklisted_filenames: Vec<String>,
    module_name: String,
}

impl AnalysisModule for Example<'_> {
    // Use this to gather data from the host computer and store it in the current data strut,
    // This is called at the start of a tick to gather the data into CurrentData strut. If there is an error return false
    fn get_data(&mut self) -> bool {
        let stringiest: Vec<&str> = vec![
            "randomName.txt",
            "Invoice.pdf.scr",
            "test.xml",
            "passwords.docs",
            "testing.png",
        ];

        self.current_data = CurrentData {
            some_file_name: stringiest[rand::thread_rng().gen_range(0, 4)],
            some_count_of_something: rand::thread_rng().gen_range(0, 100),
            something_else: rand::thread_rng().gen_range(0.0, 1000.0),
        };
        return true;
    }
    // Can leave this for todo until testing. It should do the same as get data, but return a consistent predictable 
    // dataset to current data. It will be used for unit testing
    fn get_testing_data(&mut self) -> bool {
        todo!()
    }
    // Take the current data gathered from one of the functions above, using this data, 
    // plus the persistent data stored in the object to create logs (AKA alerts) 
    fn perform_analysis(&mut self) -> Vec<crate::Log> {
        let mut results: Vec<CoreStruts::Log> = Vec::new();
        if (self.history_of_filenames.contains(&self.current_data.some_file_name))
        {
            let mut msg: String = String::from("File '");
            msg.push_str(&self.current_data.some_file_name);
            msg.push_str("' was opened twice recently");
            results.push(CoreStruts::Log::new(CoreEnums::LogType::Serious,self.module_name.clone(),msg,));
            self.history_of_filenames = Vec::new();
        } else {
            self.history_of_filenames
                .push(self.current_data.some_file_name);
        }
        self.last_string = self.current_data.some_file_name;
        return results;
    }
    fn get_name(&self) -> String{
        return self.module_name.clone();
    }
}
// Must implement on your module, defines a default constructur. This is where any code that should run when IDS is FIRST LOADED. 
// You should also initialise an empty current data strut like this
impl Default for Example<'_> {
    fn default() -> Self {
        Self {
            last_string: "",
            history_of_filenames: vec![],
            blacklisted_filenames: vec![],
            module_name: String::from("ExampleModule"),
            current_data: CurrentData {
                some_file_name: "",
                some_count_of_something: 0,
                something_else: 0.0,
            },
        }
    }
}
